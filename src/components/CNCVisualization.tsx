
import React, { useState, useRef, useEffect } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Play, Square, RotateCcw, Download } from 'lucide-react';

interface Point {
  x: number;
  y: number;
  id: number;
}

export const CNCVisualization = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [points, setPoints] = useState<Point[]>([]);
  const [isPlaying, setIsPlaying] = useState(false);
  const [currentPointIndex, setCurrentPointIndex] = useState(-1);
  const [nextPointId, setNextPointId] = useState(1);

  const CANVAS_WIDTH = 800;
  const CANVAS_HEIGHT = 600;
  const GRID_SIZE = 20;

  useEffect(() => {
    drawCanvas();
  }, [points, currentPointIndex]);

  const drawCanvas = () => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw grid
    ctx.strokeStyle = '#e5e7eb';
    ctx.lineWidth = 1;
    for (let x = 0; x <= CANVAS_WIDTH; x += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, CANVAS_HEIGHT);
      ctx.stroke();
    }
    for (let y = 0; y <= CANVAS_HEIGHT; y += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(CANVAS_WIDTH, y);
      ctx.stroke();
    }

    // Draw axes
    ctx.strokeStyle = '#9ca3af';
    ctx.lineWidth = 2;
    // X-axis
    ctx.beginPath();
    ctx.moveTo(0, CANVAS_HEIGHT - 40);
    ctx.lineTo(CANVAS_WIDTH, CANVAS_HEIGHT - 40);
    ctx.stroke();
    // Y-axis
    ctx.beginPath();
    ctx.moveTo(40, 0);
    ctx.lineTo(40, CANVAS_HEIGHT);
    ctx.stroke();

    // Draw axis labels
    ctx.fillStyle = '#6b7280';
    ctx.font = '12px sans-serif';
    ctx.fillText('X', CANVAS_WIDTH - 20, CANVAS_HEIGHT - 20);
    ctx.fillText('Y', 20, 20);

    // Draw path lines
    if (points.length > 1) {
      ctx.strokeStyle = '#3b82f6';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.stroke();
    }

    // Draw points
    points.forEach((point, index) => {
      const isActive = index === currentPointIndex;
      const isCompleted = index < currentPointIndex;
      
      ctx.beginPath();
      ctx.arc(point.x, point.y, 8, 0, 2 * Math.PI);
      
      if (isActive) {
        ctx.fillStyle = '#f59e0b'; // Current point - amber
      } else if (isCompleted) {
        ctx.fillStyle = '#10b981'; // Completed points - green
      } else {
        ctx.fillStyle = '#fbbf24'; // Default points - yellow
      }
      
      ctx.fill();
      ctx.strokeStyle = '#374151';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Draw point number
      ctx.fillStyle = '#1f2937';
      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(point.id.toString(), point.x, point.y + 4);
    });
  };

  const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
    if (isPlaying) return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;

    // Snap to grid
    const snappedX = Math.round(x / GRID_SIZE) * GRID_SIZE;
    const snappedY = Math.round(y / GRID_SIZE) * GRID_SIZE;

    const newPoint: Point = {
      x: snappedX,
      y: snappedY,
      id: nextPointId
    };

    setPoints(prev => [...prev, newPoint]);
    setNextPointId(prev => prev + 1);
  };

  const playSequence = async () => {
    if (points.length === 0) return;

    setIsPlaying(true);
    setCurrentPointIndex(0);

    for (let i = 0; i < points.length; i++) {
      setCurrentPointIndex(i);
      await new Promise(resolve => setTimeout(resolve, 800));
    }

    setTimeout(() => {
      setCurrentPointIndex(-1);
      setIsPlaying(false);
    }, 500);
  };

  const stopSequence = () => {
    setIsPlaying(false);
    setCurrentPointIndex(-1);
  };

  const clearPoints = () => {
    if (isPlaying) return;
    setPoints([]);
    setCurrentPointIndex(-1);
    setNextPointId(1);
  };

  const exportGCode = () => {
    if (points.length === 0) return;

    let gcode = '; CNC G-Code Generated by CNC Control System\n';
    gcode += 'G21 ; Set units to millimeters\n';
    gcode += 'G90 ; Absolute positioning\n';
    gcode += 'G94 ; Feed rate per minute\n';
    gcode += 'F1000 ; Set feed rate to 1000mm/min\n';
    gcode += 'M3 S1000 ; Start spindle at 1000 RPM\n\n';

    // Convert canvas coordinates to real-world coordinates (assuming 1 pixel = 0.1mm)
    points.forEach((point, index) => {
      const realX = ((point.x - 40) * 0.1).toFixed(2);
      const realY = (((CANVAS_HEIGHT - 40) - point.y) * 0.1).toFixed(2);
      
      if (index === 0) {
        gcode += `G0 X${realX} Y${realY} ; Rapid move to start position\n`;
        gcode += `G1 Z-2 ; Plunge to cutting depth\n`;
      } else {
        gcode += `G1 X${realX} Y${realY} ; Cut to point ${point.id}\n`;
      }
    });

    gcode += '\nG1 Z5 ; Retract\n';
    gcode += 'M5 ; Stop spindle\n';
    gcode += 'G0 X0 Y0 ; Return to origin\n';
    gcode += 'M30 ; Program end\n';

    const blob = new Blob([gcode], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'cnc_program.gcode';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <Card className="p-4 bg-white border border-gray-200 h-full">
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-lg font-semibold text-gray-900">CNC 2D Visualization</h3>
        <div className="flex gap-2">
          <Button 
            onClick={playSequence} 
            disabled={isPlaying || points.length === 0}
            className="bg-green-600 hover:bg-green-700"
          >
            <Play className="w-4 h-4 mr-2" />
            Play Sequence
          </Button>
          <Button 
            onClick={stopSequence} 
            disabled={!isPlaying}
            variant="outline"
          >
            <Square className="w-4 h-4 mr-2" />
            Stop
          </Button>
          <Button 
            onClick={clearPoints} 
            disabled={isPlaying}
            variant="outline"
          >
            <RotateCcw className="w-4 h-4 mr-2" />
            Clear
          </Button>
          <Button 
            onClick={exportGCode} 
            disabled={points.length === 0}
            variant="outline"
          >
            <Download className="w-4 h-4 mr-2" />
            Export G-Code
          </Button>
        </div>
      </div>

      <div className="border border-gray-300 rounded-lg overflow-hidden">
        <canvas
          ref={canvasRef}
          width={CANVAS_WIDTH}
          height={CANVAS_HEIGHT}
          onClick={handleCanvasClick}
          className="cursor-crosshair bg-white"
          style={{ display: 'block' }}
        />
      </div>

      <div className="mt-4 text-sm text-gray-600">
        <p><strong>Instructions:</strong> Click on the canvas to add waypoints. Points will be connected automatically.</p>
        <p><strong>Status:</strong> {points.length} points defined | {isPlaying ? 'Playing sequence...' : 'Ready'}</p>
      </div>
    </Card>
  );
};
